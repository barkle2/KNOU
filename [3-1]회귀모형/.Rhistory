car = read.table("car.txt", header=T)
car
machine = read.table("machine.txt", header=T)
machine
factory = read.table("factory.txt", header=T)
factory.lm = lm(str ~ temp + press, data=factory)
factory
summary(factory.lm)
factory = read.table("factory.txt", header=T)
factory.lm = lm(str ~ temp + press, data=factory)
summary(factory.lm)
anova(factory.lm)
factory
factory[, c(1:2)]
X = factory[, c(1:2)]
X = cbind(1, X)
X
X = as.matrix(X)
X
XTX = t(X) %*% X
XTX
XTXI = solve(XTX)
XTXI
XTXI[0, 0]
XTXI[1, 1]
469.4* XTXI[1,1]
469.4* XTXI[2,2]
469.4* XTXI[3,3]
469.4*XTXI[1,1];469.4*XTXI[2,2];469.4*XTXI[3,3];
X = factory[, c(1:2)]
X = cbind(1, X)
X = as.matrix(X)
XTX = t(X) %*% X
XTXI = solve(XTX)
469.4*XTXI[1,1];469.4*XTXI[2,2];469.4*XTXI[3,3];
-554.5267-0.1743*200+11.8449*59
x = c(1, 200, 59)
x
t(x)
x
t(x) %*% XTXI %*% x
0.1312068*469.4
factory
634.9+6295.7
6930.6 /2
3465.3 / 469.4
897.55+151.26+179.44
897.55+151.26
179.44/9
1076.99-1048.81
6930.6+2346.8
? qf
pf(7.38, 2, 5)
pf(26.3,2,9)
pf(26.3,2,9, lower.tail=FALSE)
pf(7.38.2,5, lower.tail=FALSE)
pf(7.38, 2,5, lower.tail=FALSE)
factory
mean(factory([1])
mean(factory[1])
mean(unlist(factory[1]))
temp_std = (factory[1] - mean(unlist(factory[1]))) / sd(unlist(factory[1]))
press_std = (factory[2] - mean(unlist(factory[2]))) / sd(unlist(factory[2]))
str_std = (factory[3] - mean(unlist(factory[3]))) / sd(unlist(factory[3]))
factory2 <- cbind(temp_std, press_std, str_std)
factory2
factory2.lm = lm(str ~ temp + press, data=factory2)
summary(factory2.lm)
temp_std = (factory[1] - mean(unlist(factory[1]))) / sd(unlist(factory[1]))
press_std = (factory[2] - mean(unlist(factory[2]))) / sd(unlist(factory[2]))
str_std = (factory[3] - mean(unlist(factory[3]))) / sd(unlist(factory[3]))
factory2 <- cbind(temp_std, press_std, str_std)
factory2.lm = lm(str ~ temp + press, data=factory2)
summary(factory2.lm)
water = read.table("water.txt", header=T)
water.lm = lm(water ~ temp+day+ton, data=water)
summary(water.lm)
anova(water.lm)
2.00432+0.00227+0.03988
(2.00432+0.00227+0.03988)/3
0.6822/0.2959
2.04647+0.17753
summary(water.lm)
2.409213 + 0.069788*20 - 0.024767*27 + 0.005864*60
TA = read.csv("p116.csv", header=T)
head(TA)
library(leaps)
install.packages("leaps")
library(leaps)
TA.lm = regsubset(Y ~. , data=TA)
TA.lm = regsubsets(Y ~. , data=TA)
summary(TA.lm)
# 앞으로부터 선택법
start.lm = lm(Y ~ 1, data=TA)
full.lm = lm(Y ~. , data=TA)
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 선택법
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 선택법
step(full.lm, data=TA, direction="backward")
# 단계별 회귀방법
step(start.lm, scope=list(upper=full.lm), data=TA, direction="both")
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 제거법
step(full.lm, data=TA, direction="backward")
# 단계별 회귀방법
step(start.lm, scope=list(upper=full.lm), data=TA, direction="both")
# 모든 가능한 회귀방법
TA.lm = regsubsets(Y ~. , data=TA)
summary(TA.lm)
rs = summary(TA.lm)
rs$rsq
rs$adjr2
rs$cp
car = read.csv("p118.csv", header=T)
# 앞으로부터 선택법
start.lm = lm(Y ~ 1, data=car)
full.lm = lm(Y ~. , data=car)
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 제거법
step(full.lm, data=TA, direction="backward")
# 단계별 회귀방법
step(start.lm, scope=list(upper=full.lm), data=TA, direction="both")
car = read.csv("p118.csv", header=T)
# 앞으로부터 선택법
start.lm = lm(Y ~ 1, data=car)
full.lm = lm(Y ~. , data=car)
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 제거법
step(full.lm, data=car, direction="backward")
# 단계별 회귀방법
step(start.lm, scope=list(upper=full.lm), data=car, direction="both")
# 모든 가능한 회귀방법
TA.lm = regsubsets(Y ~. , data=car)
rs = summary(car.lm)
# 모든 가능한 회귀방법
car.lm = regsubsets(Y ~. , data=car)
rs = summary(car.lm)
rs
rs$adjr2
# 앞으로부터 선택법
start.lm = lm(Y ~ 1, data=car)
full.lm = lm(Y ~. , data=car)
step(start.lm, scope=list(lower=start.lm, upper=full.lm), direction="forward")
# 뒤로부터 제거법
step(full.lm, data=car, direction="backward")
# 단계별 회귀방법
step(start.lm, scope=list(upper=full.lm), data=car, direction="both")
# 모든 가능한 회귀방법
car.lm = regsubsets(Y ~. , data=car)
rs = summary(car.lm)
rs
rs$adjr2
# 디렉토리 설정
setwd("D:/학습/3학년 1학기/5.회귀모형")
# 그래프를 그릴 새 창을 만든다.
graphics.off()
X11(width=8, height=8, xpos=1920, ypos=0)
X11(width=8, height=8, xpos=0, ypos=0)
# [그림 1.1] 광고료와 총판매액의 산점도
market = read.table("market-1.txt", header=T)
head(market)
plot(market$X, market$Y, xlab="광고료", ylab="총판매익", pch=19)
title("광고료와 판대액의 산점도")
market.lm = lm(Y ~ X, data=market)
summary(market.lm)
# [그림 1.2] 적합된 회귀직선
plot(market$X, market$Y, xlab="광고료", ylab="총판매익", pch=19)
title("광고료와 판매액의 산점도")
abline(market.lm)
names(market.lm)
market.lm$resid
sum(market.lm$resid)
sum(market$X*market.lm$resid)
anova(market.lm)
qf(0.95, 1, 13)
1-pf(192.9, 1, 13)
summary(market.lm)
pred.frame=data.frame(X=seq(3.5, 14.5, 0.2))
pc = predict(market.lm, int="c", newdata=pred.frame)
pp = predict(market.lm, int="p", newdata=pred.frame)
head(pc)
head(pp)
# [그림 1.4] 추정값의 신뢰구간
pred.X = pred.frame$X
pred.X
plot(market$X, market$Y, ylim=range(market$Y, pp))
matlines(pred.X, pc, lty=c(1,2,2), col="BLUE")
matlines(pred.X, pp, lty=c(1,3,3), col="RED")
summary(market.lm)
x = c(1,2,3,4,5)
y = c(2,3,5,8,7)
w = 1/x
w.lm = lm(y ~ x, weights=w)
summary(w.lm)
anova(w.lm)
# 1.7 분석사례
# (1) 자료파일 만들기
super = read.table("supermarket.txt", header=T)
head(super, 3)
# (2) 자료를 읽어 산점도 그리기
plot(super$price, super$time, pch=19)
# (3) 회귀모형 적합하기
super.lm = lm(time ~ price, data=super)
summary(super.lm)
# (4) 분산분석표 구하기
anova(super.lm)
# (5) 잔차 및 추정값 보기
names(super.lm)
cbind(super, super.lm$resid, super.lm$fitted)
# (6) 잔차그림 그리기
plot(super$price, super.lm$resid, pch=19)
abline(h=0, lty=2)
# (7) 추정값의 신뢰대 그리기
p.x = data.frame(price=c(1, 45))
pc = predict(super.lm, int="c", newdata=p.x)
pred.x = p.x$price
plot(super$price, super$time, ylim=range(super$time, pc))
matlines(pred.x, pc, lty=c(1,2,2), col="BLUE")
# 디렉토리 설정
setwd("D:/학습/3학년 1학기/5.회귀모형")
animal = read.csv("animal.csv", header=T)
animal = read.csv("animal.csv", header=T)
head(animal)
animal = read.csv("animal.csv", header=FALSE)
head(animal)
animal['V1']
animal['V2']
head(animal)
str(animal)
tail(animal)
names(animal)
names(animal) <- c("Number", "Animal_Name". "Weight", "Brain_Weight"
names(animal) <- c("Number", "Animal_Name". "Weight", "Brain_Weight")
names(animal) <- c("Number", "Animal_Name", "Weight", "Brain_Weight")
head(animal)
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19)
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게")
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
## 회귀모형 적합하기
animal.lm = lm(animal$Brain_Weight~animal$Weight, data=animal)
summary(animal.lm)
abline(animal.lm)
names(animal.lm)
cbind(animal, animal.lm$residuals, animal.lm$fitted.values)
plot(animal$Brain_Weight~animal.lm$residuals, pch=19)
abline(h=0, lty=2)
plot(animal$Brain_Weight, animal.lm$residuals, pch=19)
abline(h=0, lty=2)
# 그래프를 그릴 새 창을 만든다.
graphics.off()
plot(animal$Brain_Weight, animal.lm$residuals, pch=19)
abline(h=0, lty=2)
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
abline(h=0, lty=2)
plot(animal$Brain_Weight, animal.lm$residuals, pch=19)
plot(animal$Brain_Weight, animal.lm$residuals, pch=19, xlab="두뇌무게", ylab="잔차")
abline(h=0, lty=2)
animal_total <- cbind(animal, animal.lm$residua요ls, animal.lm$fitted.values)
animal_total <- cbind(animal, animal.lm$residuals, animal.lm$fitted.values)
animal_total
animal_total
head(animal_total)
animal_total[c(order(animal_total$animal.lm$residuals)),]
order(animal_total$animal.lm$residuals)
order(animal_total$`animal.lm$residuals`)
animal_total[c(order(animal_total$'animal.lm$residuals')),]
animal_total <- cbind(animal, animal.lm$residuals^2, animal.lm$fitted.values)
animal_total
options(scipen = 100)
animal_total
order(animal_total$`animal.lm$residuals^2`)
animal_total[c(order(animal_total$'animal.lm$residuals^2')),]
tail(animal_total[c(order(animal_total$'animal.lm$residuals^2')),])
animal_total[c(order(animal_total$'animal.lm$residuals^2')),]
animal_total[c(order(-animal_total$'animal.lm$residuals^2')),]
# 디렉토리 설정
setwd("D:/학습/3학년 1학기/5.회귀모형")
## Forbes 자료: 번호, 물끓는 온도(화씨), 대기압력
forbes = read.table("forbes.txt", header=T)
## 대기압력에 상용로그를 취한 값이 100을 곱한 값을 반응변수로 한다
forbes$Lpress = 100 * log10(forbes$press)
head(forbes)
## (Lpress, temp) 산점도
plot(forbes$temp, forbes$Lpress, pch=19)
## 원하는 점을 클릭해서 알아낸다
identify(forbes$temp, forbes$Lpress)
## 회귀선 적합
forbes.lm = lm(forbes$Lpress~forbes$temp, data=forbes)
summary(forbes.lm)
options(scipen = -100)
summary(forbes.lm)
options(scipen = 0)
summary(forbes.lm)
## 분산분석
anova(forbes.lm)
## 잔차분석
forbes.res = ls.diag(forbes.lm)
names(forbes.res)
resid.result = cbind(forbes.res$std.res, forbes.res$stud.res, forbes.res$hat)
colnames(resid.result) = c("standardized resid", "studentized resid", "Hat")
resid.result = round(resid.result, 3)
print(resid.result)
rstudent(forbes.lm)
outlierTest(forbes.lm)
outlierTest(forbes.lm)
library(car)
install.packages("car")
library(car)
install.packages("car")
install.packages("pbkrtest")
packageurl <- "https://cran.r-project.org/src/contrib/Archive/pbkrtest/pbkrtest_0.4-4.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
install.packages("car")
library(car)
outlierTest(forbes.lm)
cooks.distance(forbes.lm)
Di = cooks.distance(forbes.lm)
round(Di, 3)
ls.diag(forbes.lm)
## 스튜던트화 잔차를 보여준다
rstudent(forbes.lm)
ls.diag(forbes.lm)
plot(animal$Brain_Weight, animal.lm$residuals, pch=19, xlab="두뇌무게", ylab="잔차")
abline(h=0, lty=2)
identify(animal$Brain_Weight, animal.lm$residuals)
animal[19]
animal[19,]
animal[[19,], [32,], [33, ]]
animal[19, 32, 33]
animal[32,]
animal[33,]
animal[identify(animal$Brain_Weight, animal.lm$residuals), ]
out = animal[identify(animal$Brain_Weight, animal.lm$residuals), ]
animal[out, ]
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
# animal.csv 파일 읽기
animal = read.csv("animal.csv", header=FALSE)
# 컬럼명을 정해준다
names(animal) <- c("Number", "Animal_Name", "Weight", "Brain_Weight")
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
# animal.csv 파일 읽기
animal = read.csv("animal.csv", header=FALSE)
# 컬럼명을 정해준다
names(animal) <- c("Number", "Animal_Name", "Weight", "Brain_Weight")
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
plot(animal$Brain_Weight, animal.lm$residuals, pch=19, xlab="두뇌무게", ylab="잔차")
abline(h=0, lty=2)
### 회귀모형 적합하기
animal.lm = lm(animal$Brain_Weight~animal$Weight, data=animal)
### 회귀모형 확인
summary(animal.lm)
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
### 회귀모형 확인
summary(animal.lm)
# 두뇌무게:Y, 몸무게:X 로 산점도 및 잔차산점도 그리기
## 산점도 그리기
plot(animal$Brain_Weight~animal$Weight, pch=19, xlab="몸무게", ylab="두뇌무게")
### 산점도에 회귀선을 그린다
abline(animal.lm)
animal_diag = ls.diag(animal.lm)
animal_diag
rstudent(animal.lm)
animal[order(rstudent(animal.lm))]
order(rstudent(animal.lm))
order(rstudent(animal.lm)^2)
order(-rstudent(animal.lm)^2)
rstudent_2 = -rstudent(animal.lm)^2
rstudent_2[order(-rstudent(animal.lm)^2)]
options(scipen = 0)
rstudent_2[order(-rstudent(animal.lm)^2)]
rstudent_2 = round(rstudent_2, 3)
rstudent_2
rstudent_2[order(-rstudent(animal.lm)^2)]
outlierTest(animal.lm)
cooks.distance(animal.lm)
# 특이점 검정
outlierTest(animal.lm)
# 쿡의 거리로 관측값 영향력 계산
cooks.distance(animal.lm)
# 쿡의 거리로 관측값 영향력 계산
Di = cooks.distance(animal.lm)
Di = round(Di, 3)
Di = Di[-order(Di)]
Di
# 쿡의 거리로 관측값 영향력 계산
Di = cooks.distance(animal.lm)
Di
Di = round(Di, 3)
Di
-order(Di)
Di[-order(Di)]
Di[order(Di)]
Di = Di[order(-Di)]
Di
# 특이점 검정
outlierTest(animal.lm)
# 쿡의 거리로 관측값 영향력 계산
Di = cooks.distance(animal.lm)
Di = round(Di, 3)
Di[order(-Di)]
# 특이점 검정
outlierTest(animal.lm)
# 쿡의 거리로 관측값 영향력 계산
Di = cooks.distance(animal.lm)
Di = round(Di, 3)
Di[order(-Di)]
animal[19,]
rbind(animal[19,], animal[32,], animal[33, ])
ncvTest(animal.lm)
# 등분산 가정의 성립 여부 확인
ncvTest(animal.lm)
# 등분산 가정의 성립 여부 확인
ncvTest(animal.lm)
# 회귀모형의 선형성 확인
plot(animal$Weight, animal.lm$residuals, pch=19, xlab="두뇌무게", ylab="잔차")
library(mvnormtest)
install.packages("mvnormtest")
library(mvnormtest)
animal.rstudent = rstudent(animal.lm)
shapiro.test(animal.rstudent)
# 오차의 정규성 확인
animal.rstudent = rstudent(animal.lm)
shapiro.test(animal.rstudent)
head(animal)
# animal에 로그 변환한 값을 추가한다
log(animal$Weight)
# animal에 로그 변환한 값을 추가한다
animal$Weight
animal$Lweight = log(animal$Weight)
animal$Lbrain_Weight = log(animal$Brain_Weight)
head(animal)
head(animal)
# animal.csv 파일 읽기
animal = read.csv("animal.csv", header=FALSE)
# 컬럼명을 정해준다
names(animal) <- c("Number", "Animal_Name", "Weight", "Brain_Weight")
# animal에 로그 변환한 값을 추가한다
animal$LWeight = log(animal$Weight)
animal$LBrain_Weight = log(animal$Brain_Weight)
head(animal)
### 회귀모형 적합하기
animal.Llm = lm(animal$LBrain_Weight~animal$LWeight, data=animal)
### 회귀모형 확인
summary(animal.Llm)
### 산점도 및 회귀직선 그릭
plot(animal$LBrain_Weight, animal$LWeight, data=animal)
### 산점도 및 회귀직선 그릭
plot(animal$LBrain_Weight, animal$LWeight, data=animal)
### 산점도 및 회귀직선 그릭
plot(animal$LBrain_Weight, animal$LWeight, pch=19)
abline(animal.Llm)
### 회귀모형 적합하기
animal.Llm = lm(animal$LBrain_Weight~animal$LWeight, data=animal)
### 회귀모형 확인
summary(animal.Llm)
### 산점도 및 회귀직선 그리기
plot(animal$LBrain_Weight~animal$LWeight, pch=19)
abline(animal.Llm)
# 특이점 검정
outlierTest(animal.Llm)
out = animal[identify(animal$LBrain_Weight, animal$LWeight, ]
out = animal[identify(animal$LBrain_Weight, animal$LWeight), ]
out = animal[identify(animal$LBrain_Weight, animal$LWeight), ]
identify(animal$LBrain_Weight, animal$LWeight)
identify(animal$LBrain_Weight, animal$LWeight)
### 산점도 및 회귀직선 그리기
plot(animal$LBrain_Weight~animal$LWeight, pch=19)
identify(animal$LBrain_Weight, animal$LWeight)
identify(animal$LBrain_Weight~animal$LWeight)
# 쿡의 거리로 관측값 영향력 계산
Di = cooks.distance(animal.Llm)
Di = round(Di, 3)
Di[order(-Di)]
# 등분산 가정의 성립 여부 확인
ncvTest(animal.Llm)
# 회귀모형의 선형성 확인
plot(animal$LWeight, animal.Llm$residuals, pch=19, xlab="두뇌무게", ylab="잔차")
# 회귀모형의 선형성 확인
plot(animal$LWeight, animal.Llm$residuals, pch=19, xlab="두뇌무게(로그)", ylab="잔차")
# 오차의 정규성 확인
animal.rstudent = rstudent(animal.lm)
# 오차의 정규성 확인
animal.rstudent = rstudent(animal.Llm)
shapiro.test(animal.rstudent)
# animal에 로그 변환한 값을 추가한다
animal$LWeight = log(animal$Weight)
animal$LBrain_Weight = log(animal$Brain_Weight)
head(animal)
### 회귀모형 적합하기
animal.Llm = lm(animal$LBrain_Weight~animal$LWeight, data=animal)
### 회귀모형 확인
summary(animal.Llm)
### 산점도 및 회귀직선 그리기
plot(animal$LBrain_Weight~animal$LWeight, pch=19)
abline(animal.Llm)
